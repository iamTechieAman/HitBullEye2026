
# Array Rotation in Java (Left Rotation)

This document explains how to **rotate an array to the left by `d` positions** using three different techniques.
Each approach improves on the previous one in terms of **time and space efficiency**.

---

## Problem Statement

Given an integer array `arr[]` of size `n` and an integer `d`, rotate the array **to the left by `d` positions**.

### Example

**Input**

```
arr = [1, 2, 3, 4, 5]
d = 2
```

**Output**

```
[3, 4, 5, 1, 2]
```

---

## Approach 1: Brute Force Method (Repeated Shifting)

### Idea

* Rotate the array **one position at a time**
* Repeat this process `d` times
* In each rotation:

    * Store the first element
    * Shift all elements one step to the left
    * Move the first element to the end

---

### Java Code

```java
static void rotateArr(int[] arr, int d) {
    int n = arr.length;

    for (int i = 0; i < d; i++) {
        int first = arr[0];

        for (int j = 0; j < n - 1; j++) {
            arr[j] = arr[j + 1];
        }
        arr[n - 1] = first;
    }
}
```

---

### Complexity Analysis

* **Time Complexity:** `O(n × d)`
* **Space Complexity:** `O(1)`

---

### Drawback

This approach is **slow** when `d` or `n` is large.

---

## Approach 2: Using Temporary Array

### Idea

* Use an extra array to store the rotated result
* First copy elements from index `d` to the end
* Then copy the first `d` elements at the end
* Finally, copy the temporary array back to the original array

---

### Java Code

```java
static void rotateArr(int[] arr, int d) {
    int n = arr.length;
    d %= n;

    int[] temp = new int[n];

    for (int i = 0; i < n - d; i++)
        temp[i] = arr[d + i];

    for (int i = 0; i < d; i++)
        temp[n - d + i] = arr[i];

    for (int i = 0; i < n; i++)
        arr[i] = temp[i];
}
```

---

### Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(n)`

---

### Advantage

Faster than brute force and easy to understand.

---

### Drawback

Uses **extra memory**, which may not be ideal in memory-constrained systems.

---

## Approach 3: Reversal Algorithm (Most Efficient)

### Idea

Rotate the array by reversing parts of it:

1. Reverse the first `d` elements
2. Reverse the remaining `n - d` elements
3. Reverse the entire array

This gives the final rotated array.

---

### Java Code

```java
static void rotateArr(int[] arr, int d) {
    int n = arr.length;
    d %= n;

    reverse(arr, 0, d - 1);
    reverse(arr, d, n - 1);
    reverse(arr, 0, n - 1);
}

static void reverse(int[] arr, int start, int end) {
    while (start < end) {
        int temp = arr[start];
        arr[start] = arr[end];
        arr[end] = temp;
        start++;
        end--;
    }
}
```

---

### Complexity Analysis

* **Time Complexity:** `O(n)`
* **Space Complexity:** `O(1)`

---

### Advantage

* Most **efficient**
* No extra memory used
* Preferred in **interviews and competitive programming**

---

## Key Concepts Used

* Array manipulation
* Modular arithmetic
* Reversal technique
* Time–space optimization

---

## Conclusion

Array rotation can be solved in multiple ways, but the **reversal algorithm** is the best choice due to its **optimal time and space complexity**.
Understanding all approaches helps in selecting the right solution based on constraints.

---

