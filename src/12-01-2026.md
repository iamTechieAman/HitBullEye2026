
---

# Coding Questions – Binary Search in Java

This document covers **Binary Search** and its application in solving the LeetCode problem **“Find First and Last Position of Element in Sorted Array”**.

---

## 1. Binary Search

### Problem Statement

Given a **sorted array** and a target element `x`, find the index of `x` in the array.
If the element is not present, return `-1`.

---

### Algorithm (Binary Search)

1. Initialize two pointers:

    * `low` at the beginning of the array
    * `high` at the end of the array
2. Find the middle index.
3. Compare the middle element with the target:

    * If equal → return index
    * If smaller → search right half
    * If greater → search left half
4. Repeat until `low > high`
5. If not found, return `-1`

---

### Java Code

```java
static int binarySearch(int arr[], int x) {
    int low = 0, high = arr.length - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2;

        if (arr[mid] == x)
            return mid;

        if (arr[mid] < x)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}
```

---

### Time & Space Complexity

* **Time Complexity:** `O(log n)`
* **Space Complexity:** `O(1)`

---

## 2. LeetCode – Find First and Last Position of Element in Sorted Array

### Problem Statement

Given a sorted integer array `nums` and a target value, find the **first and last position** of the target.
If the target is not found, return `-1`.

---

### Approach

To find the **first occurrence**:

* Use Binary Search
* When the target is found, store the index
* Continue searching on the **left side** to find the earliest position

---

### Java Code – First Position

```java
public static int firstPosition(int[] nums, int target) {
    int ans = -1;
    int n = nums.length;
    int l = 0;
    int r = n - 1;

    while (l <= r) {
        int mid = l + (r - l) / 2;

        if (nums[mid] == target) {
            ans = mid;
            r = mid - 1;   // move left to find first occurrence
        }
        else if (nums[mid] < target) {
            l = mid + 1;
        }
        else {
            r = mid - 1;
        }
    }
    return ans;
}
```

---

### Explanation

* `ans` stores the index of the target
* Even after finding the target, search continues on the **left side**
* This ensures the **first occurrence** is returned

---

### Time & Space Complexity

* **Time Complexity:** `O(log n)`
* **Space Complexity:** `O(1)`

---

## Key Concepts Used

* Binary Search
* Divide and Conquer
* Loop-based implementation
* Efficient searching in sorted arrays

---

## Conclusion

Binary Search is one of the most efficient searching algorithms for sorted data.
Its modified versions are widely used in problems like finding **first and last occurrences**, making it an essential concept for **DSA, interviews, and competitive programming**.

---
